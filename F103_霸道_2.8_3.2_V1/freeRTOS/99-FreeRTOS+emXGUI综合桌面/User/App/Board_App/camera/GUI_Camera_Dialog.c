#include <emXGUI.h>
#include <string.h>
#include "Widget.h"
#include "bsp_ov7725.h"
#include "x_libc.h"




TaskHandle_t h_autofocus;
BOOL update_flag = 0;//帧率更新标志
uint8_t fps=0;//帧率
HWND Cam_hwnd;//主窗口句柄
static SURFACE *pSurf;
GUI_SEM *cam_sem = NULL;//更新图像同步信号量（二值型）
uint16_t *cam_buff;

/*
 * @brief  读一整帧图像
 * @param  图像的缓冲区
 * @retval NONE
*/
void OV7725_Read_Frame(uint16_t *p)
{
  /* 进入临界段，临界段可以嵌套 */
//  taskENTER_CRITICAL();
  
  for(int i = 0; i < 240*320; i++)
  {
    READ_FIFO_PIXEL(*p);		/* 从FIFO读出一个 rgb565 像素到 p 变量 */
    p++;
  }
  
//  taskEXIT_CRITICAL();
}

/*
 * @brief  更新屏幕
 * @param  NONE
 * @retval NONE
*/
static void Update_Dialog()
{
  /* ov7725 场信号线初始化 */
  Ov7725_vsync = 0;
  VSYNC_Init();
  
	while(1) //线程已创建了
	{
    GUI_SemWait(cam_sem, 0xFFFFFFFF);
  
    FIFO_PREPARE;  			/*FIFO准备*/

    OV7725_Read_Frame(cam_buff);    // 读一帧图像
    fps ++;                         // 帧率自加

    InvalidateRect(Cam_hwnd,NULL,FALSE);
	}
}

/*
 * @brief  摄像头窗口回调函数
*/
static LRESULT WinProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  static uint8_t OV7725_State = 0;    // 0:可以检测到摄像头
  static int old_fps = 0;
  
  switch(msg)
  {
    case WM_CREATE:
    {
      /* ov7725 gpio 初始化 */
      Ov7725_GPIO_Config();

      if(Ov7725_Init())
      {
        GUI_DEBUG("OV7725 初始化成功");
        OV7725_State = 0;
      }
      else
      {
        MSGBOX_OPTIONS ops;
        //const WCHAR *btn[]={L"确定"};
        int x,y,w,h;

        ops.Flag =MB_ICONERROR;
        //ops.pButtonText =btn;
        ops.ButtonCount =0;
        w =200;
        h =120;
        x =(GUI_XSIZE-w)>>1;
        y =(GUI_YSIZE-h)>>1;
        MessageBox(hwnd,x,y,w,h,L"没有检测到OV7725摄像头，\n请重新检查连接。",L"错误",&ops); 
        OV7725_State = 1;     // 没有检测到摄像头
        PostCloseMessage(hwnd);
        break;  
      }     
      
      pSurf =CreateSurface(SURF_RGB565,320, 240, 0, (U16 *)cam_buff);   
      cam_sem = GUI_SemCreate(0,1);//同步摄像头图像
      
      //创建自动对焦线程
      xTaskCreate((TaskFunction_t )(void(*)(void*))Update_Dialog,  /* 任务入口函数 */
                            (const char*    )"Update_Dialog",/* 任务名字 */
                            (uint16_t       )1*1024/4,  /* 任务栈大小FreeRTOS的任务栈以字为单位 */
                            (void*          )NULL,/* 任务入口函数参数 */
                            (UBaseType_t    )5, /* 任务的优先级 */
                            (TaskHandle_t  )&h_autofocus);/* 任务控制块指针 */

      
      SetTimer(hwnd,1,999,TMR_START,NULL);  

      break;  
    }
    case WM_LBUTTONDOWN://点击屏幕，关闭窗口
    {
      
      PostCloseMessage(hwnd);
  
      break;
    }
    case WM_TIMER://摄像头状态机
    {
      update_flag = 1;

      break;
    }
    case WM_PAINT:
    {
      PAINTSTRUCT ps;
//      SURFACE *pSurf;
      HDC hdc_mem;
      HDC hdc;
      WCHAR wbuf[20];
      RECT rc;
      
      hdc = BeginPaint(hwnd,&ps);
      GetClientRect(hwnd,&rc);
      if(OV7725_State == 1)
      {
        SetTextColor(hdc,MapRGB(hdc,250,250,250));
        SetBrushColor(hdc,MapRGB(hdc,50,0,0));
        SetPenColor(hdc,MapRGB(hdc,250,0,0));
        
        DrawText(hdc,L"正在初始化摄像头\r\n\n请等待...",-1,&rc,DT_VCENTER|DT_CENTER|DT_BKGND);
      }              
      if(OV7725_State == 0)
      {   
        
        hdc_mem =CreateDC(pSurf,NULL);
        BitBlt(hdc, 0, 0, 320, 240, hdc_mem, 0 , 0, SRCCOPY);

        DeleteDC(hdc_mem);
      }
#if 0
      // 更新窗口分辨率
      if(update_flag)
      {
        update_flag = 0;
        old_fps = fps;
        fps = 0;
      }
      
      rc.x = 0;
      rc.y = 0;
      rc.w = 70;
      rc.h = 15;
      
      x_wsprintf(wbuf,L"帧率:%dFPS",old_fps);
      DrawText(hdc,wbuf,-1,&rc,DT_VCENTER|DT_CENTER);
#endif
      EndPaint(hwnd,&ps);
      Ov7725_vsync = 0;    // 开始下一帧图像的采集
      break;
    }

    case WM_DESTROY:
    {
      old_fps = 0;
      fps = 0;
      DeleteSurface(pSurf);

      if (!OV7725_State)
      {
        GUI_Thread_Delete(h_autofocus);
      }

      GUI_VMEM_Free(cam_buff);
      discameraexit();             // 关闭中断
      GUI_SemDelete(cam_sem);
      return PostQuitMessage(hwnd);	
    }    
    default:
      return DefWindowProc(hwnd, msg, wParam, lParam);
  }
  return WM_NULL;
}


void	GUI_Camera_DIALOG(void)
{	
	WNDCLASS	wcex;
	MSG msg;

	wcex.Tag = WNDCLASS_TAG;  
  
  cam_buff = (uint16_t *)GUI_VMEM_Alloc(LCD_XSIZE*LCD_YSIZE*2);
  
	wcex.Style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WinProc; //设置主窗口消息处理的回调函数.
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = NULL;//hInst;
	wcex.hIcon = NULL;//LoadIcon(hInstance, (LPCTSTR)IDI_WIN32_APP_TEST);
	wcex.hCursor = NULL;//LoadCursor(NULL, IDC_ARROW);

	//创建主窗口
	Cam_hwnd = CreateWindowEx(WS_EX_NOFOCUS,
                                    &wcex,
                                    L"GUI_Camera_Dialog",
                                    WS_VISIBLE|WS_CLIPCHILDREN|WS_OVERLAPPED,
                                    0, 0, GUI_XSIZE, GUI_YSIZE,
									NULL, NULL, NULL, NULL);

	//显示主窗口
	ShowWindow(Cam_hwnd, SW_SHOW);

	//开始窗口消息循环(窗口关闭并销毁时,GetMessage将返回FALSE,退出本消息循环)。
	while (GetMessage(&msg, Cam_hwnd))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
  }


}
